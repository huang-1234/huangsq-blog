(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{567:function(v,_,e){"use strict";e.r(_);var n=e(6),p=Object(n.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"mysql-索引和-sql-调优总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql-索引和-sql-调优总结"}},[v._v("#")]),v._v(" MySQL 索引和 SQL 调优总结")]),v._v(" "),e("p",[v._v("MySQL 索引#\nMySQL 支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此 MySQL 数据库支持多种索引类型，如 BTree 索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于 BTree 索引，因为这是平常使用 MySQL 时主要打交道的索引。")]),v._v(" "),e("p",[v._v("MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。")]),v._v(" "),e("p",[v._v("MySQL 索引原理\n索引目的")]),v._v(" "),e("p",[v._v("索引的目的在于提高查询效率，可以类比字典，如果要查 “mysql” 这个单词，我们肯定需要定位到 m 字母，然后从下往下找到 y 字母，再找到剩下的 sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到 m 开头的单词呢？或者 ze 开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？")]),v._v(" "),e("p",[v._v("咱们去图书馆借书也是一样，如果你要借某一本书，一定是先找到对应的分类科目，再找到对应的编号，这是生活中活生生的例子，通用索引，可以加快查询速度，快速定位。")]),v._v(" "),e("p",[v._v("索引原理")]),v._v(" "),e("p",[v._v("所有索引原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。")]),v._v(" "),e("p",[v._v("数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询 (>、<、between)、模糊查询 (like)、并集查询 (or)、多值匹配（in【in 本质上属于多个 or】）等等。数据库应该选择怎么样的方式来应对所有的问题呢？")]),v._v(" "),e("p",[v._v("我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果 1000 条数据，1 到 100 分成第一段，101 到 200 分成第二段，201 到 300 分成第三段…… 这样查第 250 条数据，只要找第三段就可以了，一下子去除了 90% 的无效数据。但如果是 1 千万的记录呢，分成几段比较好？")]),v._v(" "),e("p",[v._v("稍有算法基础的同学会想到搜索树，其平均复杂度是 lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。")]),v._v(" "),e("p",[v._v("索引结构")]),v._v(" "),e("p",[v._v("任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘 IO 次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b + 树应运而生。")]),v._v(" "),e("p",[v._v("b + 树的索引结构解释")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。")]),v._v(" "),e("p",[v._v("b + 树的查找过程")]),v._v(" "),e("p",[v._v("如图所示，如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。")]),v._v(" "),e("p",[v._v("真实的情况是，3 层的 b + 树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。")]),v._v(" "),e("p",[v._v("b + 树性质")]),v._v(" "),e("p",[v._v("1、通过上面的分析，我们知道间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint8 字节少一半。这也是为什么 b + 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于 1 时将会退化成线性表。")]),v._v(" "),e("p",[v._v("2、当 b + 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b + 数是按照从左到右的顺序来建立搜索树的，比如当 (张三，20,F) 这样的数据来检索的时候，b + 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b + 树就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。")]),v._v(" "),e("p",[v._v("比如当 (张三，F) 这样的数据来检索时，b + 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。")]),v._v(" "),e("p",[v._v("MySQL 索引实现\n在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。")]),v._v(" "),e("p",[v._v("MyISAM 索引实现")]),v._v(" "),e("p",[v._v("MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("这里设表一共有三列，假设我们以 Col1 为主键，则上图便是一个 MyISAM 表的主索引（Primary key）示意图。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。")]),v._v(" "),e("p",[v._v("MyISAM 的索引方式也叫做 “非聚集” 的，之所以这么称呼是为了与 InnoDB 的聚集索引区分。")]),v._v(" "),e("p",[v._v("InnoDB 索引实现")]),v._v(" "),e("p",[v._v("虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。")]),v._v(" "),e("p",[v._v("第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。")]),v._v(" "),e("p",[v._v("了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。")]),v._v(" "),e("p",[v._v("如何建立合适的索引\n建立索引的原理")]),v._v(" "),e("p",[v._v("一个最重要的原则是最左前缀原理，在提这个之前要先说下联合索引，MySQL 中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为 1 的特例。")]),v._v(" "),e("p",[v._v("索引匹配的最左原则具体是说，假如索引列分别为 A，B，C，顺序也是 A，B，C：")]),v._v(" "),e("p",[v._v("那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询")]),v._v(" "),e("p",[v._v("如果查询的时候，采用【A，C】，那么 C 这个虽然是索引，但是由于中间缺失了 B，因此 C 这个索引是用不到的，只能用到 A 索引")]),v._v(" "),e("p",[v._v("如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了")]),v._v(" "),e("p",[v._v("如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引")]),v._v(" "),e("p",[v._v("因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好")]),v._v(" "),e("p",[v._v("在使用 InnoDB 存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。如果从数据库索引优化角度看，使用 InnoDB 引擎而不使用自增主键绝对是一个糟糕的主意。")]),v._v(" "),e("p",[v._v("InnoDB 使用聚集索引，数据记录本身被存于主索引（一颗 B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL 会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB 默认为 15/16），则开辟一个新的页（节点）。如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。")])])}),[],!1,null,null,null);_.default=p.exports}}]);