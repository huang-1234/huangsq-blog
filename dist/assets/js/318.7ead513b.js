(window.webpackJsonp=window.webpackJsonp||[]).push([[318],{834:function(_,v,t){"use strict";t.r(v);var a=t(6),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"数据分析中的客户端埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据分析中的客户端埋点"}},[_._v("#")]),_._v(" 数据分析中的客户端埋点")]),_._v(" "),t("h2",{attrs:{id:"客户端埋点简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端埋点简介"}},[_._v("#")]),_._v(" 客户端埋点简介")]),_._v(" "),t("p",[_._v("在传统的Web APP和 Native APP开发的产品中，埋点从技术的角度来说未必多深奥，但从业务的角度来说要做到设计规范、流程高效和保证质量却很难。每个业务版本中都可能会有数据埋点工作，那工作中的数据埋点是怎么运转的呢？本文将来讨论数据分析中客户端埋点那些事儿。")]),_._v(" "),t("p",[_._v("不知道小伙伴们有没有注意到，")]),_._v(" "),t("p",[_._v("经常访问的网站/app，")]),_._v(" "),t("p",[_._v("总能推送到你感兴趣的内容，")]),_._v(" "),t("p",[_._v("简直比亲爹妈还了解你的喜好图片")]),_._v(" "),t("p",[_._v("他们是会读心术吗？")]),_._v(" "),t("p",[_._v("NO！NO！NO！")]),_._v(" "),t("p",[_._v("是因为他们在你访问网站/app时")]),_._v(" "),t("p",[_._v("顺手安插了一个卧底图片")]),_._v(" "),t("p",[_._v("随时随地打小报告💢")]),_._v(" "),t("p",[_._v("今天Labs就带大家来揭开")]),_._v(" "),t("p",[_._v("这个卧底的真面目图片")]),_._v(" "),t("p",[t("strong",[_._v("Part 01")])]),_._v(" "),t("p",[t("strong",[_._v("● 啥是埋点 ●")])]),_._v(" "),t("p",[_._v("埋点是网站/app安插在你身边的卧底，他会记录用户的信息和行为，比如这样一条小报告 “张三在2021-2-3 15:30访问了和家亲生态合作平台的首页，观看10分钟的Andlink学院的视频”就记录了用户的身份、访问的时间、访问的页面、特定的行为(观看视频)、停留的时间等等信息。当然，埋点只会报告老板交代要记录的，其他的就睁一只眼闭一只眼了。老板通常会关注这几个方面：页面的访问频率、页面的停留时间、页面上元素的点击次数。通过这几个指标，就能分析出用户关注或者感兴趣的内容，从而做针对性的推送了。")]),_._v(" "),t("p",[t("strong",[_._v("Part 02")])]),_._v(" "),t("p",[t("strong",[_._v("● 埋点的分类 ●")])]),_._v(" "),t("p",[_._v("接下来我们来看看埋点都有哪些种类。首先根据这个卧底的工作地分类，可以分为两种：一种驻地在用户浏览器或者手机上的叫做客户端埋点（前端埋点），一种在本部服务器工作的叫服务端埋点（后端埋点）。")]),_._v(" "),t("p",[_._v("客户端埋点由于驻地办公，能收集的信息非常全面，特别是诸如用户点击等界面交互行为，由于不需要请求服务器，因此只有客户端埋点才能采集到。不过由于采集的数据需要通过网络上报，受用户网络不稳定的影响，可能会出现漏报的情况。此外如果客户端是APP，当埋点需要更新或者有新埋点时，需要用户更新APP才能生效，如果有部分钉子户一直不更新，就会影响埋点的质量。相反的，服务端埋点在面对埋点有更新或者有新埋点时毫无压力，但是对于客户端界面交互上的行为信息则无能为力。")]),_._v(" "),t("p",[_._v("客户端埋点根据实现的方式的不同，还可以进一步分为全埋点、可视化埋点、代码埋点。")]),_._v(" "),t("p",[_._v("全埋点又叫自动埋点或者无埋点，是指在产品中嵌入埋点SDK，从而自动采集所有的用户交互行为信息进行上报。这种方式简单粗暴，工作量最小，但是缺点也很明显。首先是采集的数据量很大，这样一来增加了数据上报过程中的流量消耗，二来增加了后续对埋点数据进行数据分析时的工作量。其次，全埋点的方式只能携带基本的交互行为信息，没法上报行为附带的属性信息，因此在数据分析时无法提供更精确的数据。")]),_._v(" "),t("p",[_._v("可视化埋点可以将网站或者app的真实界面展示预览，通过提供可交互的界面，让产品或者运营人员可以直接在页面上添加埋点，并且埋点之后可以立即验证埋点的正确与否。这种埋点方式可以降低埋点实施的门槛，让产品或者运营人员得以在无需研发人员的介入下自行埋点，提升了工作流程的效率。而且相比全埋点，可视化埋点的目标更准确，降低了埋点的数量，减少了网络流量负担。但是可视化埋点同样具有很多局限。一来与全埋点一样，同样难以实现对行为添加附带属性；二来可视化埋点只能针对可见元素添加埋点，一些动态页面或者不可见的行为无法采集。")]),_._v(" "),t("p",[_._v("代码埋点是最经典的埋点方式，通过研发人员将埋点代码结合到业务代码中，实现定制化的用户行为数据采集。很多其他埋点方式力所不能及的行为数据采集，代码埋点都能胜任，而且代码埋点可以轻松的为行为添加各种需要的业务属性。但是这种埋点方式显然成本更高，而且由于与业务代码耦合在一起，因此容错率更低，维护成本也更高。")]),_._v(" "),t("p",[_._v("由此可见，三种埋点方式各有利弊，可根据不同的使用场景进行选择。如果是在项目早期，没有明确的业务分析需求，或者研发资源稀缺，亦或者是活动类的页面，可以采用全埋点或者可视化埋点节省埋点成本；而在项目发展到一定规模时，有了更为精确的分析需求，对埋点数据质量的要求更高之后，采用代码埋点的方式。")]),_._v(" "),t("p",[t("strong",[_._v("Part 03")])]),_._v(" "),t("p",[t("strong",[_._v("● 埋点数据的上报 ●")])]),_._v(" "),t("p",[_._v("如前文所述，在通过客户端埋点采集完数据之后，需要通过网络传输上报到服务器。常见的上报实现可以分为以下几种：")]),_._v(" "),t("p",[_._v("1、XHR接口请求上报：这是最简单粗暴的方式，通过调用XMLHttpRequest进行埋点数据的上报，采用异步请求的方式可以避免阻塞页面的交互，但是由于javascript单线程的运行机制，一定程度上还是会出现对网络资源的竞争情况。此外，由于业务服务器和埋点服务器通常是各自独立的，客户端想直接上报数据给埋点服务器是会被浏览器拦截的，必须要做跨域的处理。另一方面，如果在上报途中页面出现跳转、刷新、关闭等情况，造成页面的销毁时，浏览器并不会等待异步xhr接口请求完毕，而是会直接无情的“拔网线”中断传输，导致上报数据中途丢失。尽管可以通过设置同步请求的方式要求浏览器等待数据上报完成，但这样一来用户也会一起被迫加入等待的行列，显然对用户体验是有损害的。")]),_._v(" "),t("p",[_._v("2、img、script等标签：通过把上报数据伪装成图片或者script脚本请求，可以规避掉上面xhr出现的跨域问题。其中img标签相较script标签，由于不需要插入dom即可发起请求，因此一定程度上还有更好的性能表现。但是这种方式有个问题就是由于上报的数据都被一股脑拼接到url上了，会导致url变得很长。但浏览器通常都会对url的长度做出限制，因此这种方式无法上报过多的埋点数据，需要进行拆封上报。此外，这种方式在面对页面的跳转、关闭、刷新时，同样难逃浏览器的“拔网线”的命运。")]),_._v(" "),t("p",[_._v("3、sendBeacon：鉴于xhr接口请求和img、script标签在面对浏览器“拔网线”上的无能为力，sendBeacon应运而生。sendBeacon可以说是为埋点量身定做的，他既没有xhr的跨域问题，也无惧浏览器的“拔网线”行为，可以确保数据完成上报，十分可靠。而且是异步传输的方式，并不会影响下一页面的展示。唯一的小小缺点，就是在一些元老级别的浏览器上会有兼容性问题，出现水土不服。")]),_._v(" "),t("p",[t("strong",[_._v("Part 04")])]),_._v(" "),t("p",[t("strong",[_._v("● 埋点的应用 ●")])]),_._v(" "),t("p",[_._v("埋点分析是网站和APP等产品分析的最常用的数据采集方法。也是一种良好的私有化部署数据采集方式。\n友盟和talking data是目前国内最常用的移动APP第三方统计工具。俗称[APP埋点工具]。")]),_._v(" "),t("p",[t("strong",[_._v("目前[APP埋点]的主流有两种方式：")]),_._v("\n第一类是预先设定好想要获取的目标数据，让程序员撰写代码把“采集器”埋到相应的页面上，用于追踪和记录的用户的行为，并把实时数据传送到后台数据库或者客户端。\n第二类方法是利用第三方统计工具插件（如友盟、百度移动、魔方、App Annie、talking data、神策数据等）手机想要获得的数据，但是这样的话你的数据就可能会被第三方掌握了。\n扩展阅读：[教你如何选择免费的移动APP数据分析平台]和[APP产品设计师和APP运营专员的入门课程《看数据》]")]),_._v(" "),t("p",[t("strong",[_._v("企业进行埋点的宏观目标：")]),_._v("\n是为了获取数据指标来整体上验证产品的业务逻辑是否顺畅，之前的一些基本假设是否成立？ 特别是以数据驱动的企业，特别注重[APP埋点]的执行和[APP埋点]的分析。\n这时候涉及需要验证的数据可能会涵盖："),t("strong",[_._v("产品方向&市场运营&商业逻辑")]),_._v("（假设有）三大方面。\n通过优先级和深入度可以将指标拆解为，"),t("strong",[_._v("核心指标")]),_._v("和"),t("strong",[_._v("相关衍生指标")]),_._v("。\n扩展阅读：[APP运营人员的详细运营指标图，供你参考]")]),_._v(" "),t("p",[t("strong",[_._v("数据埋点的具体目的是：")]),_._v("\n一、在产品流程关键部位植相关统计代码，用来追踪每次用户的行为，统计关键流程的使用程度。\n二、在产品中植入多段代码追踪用户连续行为，建立用户模型来具体化用户在使用产品中的操作行为。\n三、与研发及数据分析师团队合作，通过数据埋点还原出用户画像及用户行为，建立数据分析后台，通过数据分析、优化产品。\n以上也是APP数据埋点分三个阶段。")]),_._v(" "),t("p",[t("strong",[_._v("通过埋点我们可以拿到以下四大想要的的目标数据：")]),_._v("\n1、行为数据：时间、地点、人物、交互、交互的内容；\n2、质量数据：浏览器加载情况、错误异常等；\n3、环境数据：浏览器相关的元数据以及地理、运营商等；\n4、运营数据：PV、UV、转化率、留存率（很直观的数据）;")]),_._v(" "),t("p",[t("strong",[_._v("[APP埋点内容]：")]),_._v(" "),t("strong",[_._v("1、是统计应用页面访问情况，即页面统计；")]),_._v("\n页面统计，可以统计应用内各个页面的访问次数（PV）,访问设备数（UV）和访问时长，以及各页面之间的流向关系。\n"),t("strong",[_._v("2、是统计应用内的操作行为，及自定义事件统计。")]),_._v("\n自定义事件，即记录用户的操作行为（如点击行为），记录用户操作行为中的具体细节；一般来说，通常所说的埋点，指的就是自定义事件。\n埋点可以是某个按钮，某个点击区域，某个提示，甚至可以用来统计一些特定的代码是否被执行。在APP中，需要在代码中定义一个事件行为。")]),_._v(" "),t("p",[_._v("最终，进行埋点本身其实是对于自己所设计产品的一个可视化健康检查，通过逻辑和数据，贯穿产品的整个生命周期，使产品逐步达到最佳状态从而实现硅谷最近所谓的“Growth Hacker”的效果，使产品指数级增长。")]),_._v(" "),t("h2",{attrs:{id:"前端监控和前端埋点方案设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端监控和前端埋点方案设计"}},[_._v("#")]),_._v(" 前端监控和前端埋点方案设计")]),_._v(" "),t("p",[_._v("在线上项目中,需要统计产品中用户行为和使用情况，从而可以从用户和产品的角度去了解用户群体，从而升级和迭代产品，使其更加贴近用户。用户行为数据可以通过前端数据监控的方式获得，除此之外，前端还需要实现性能监控和异常监控。性能监控包括首屏加载时间、白屏时间、http请求时间和http响应时间。异常监控包括前端脚本执行报错等。")]),_._v(" "),t("p",[_._v("实现前端监控有三个步骤：前端埋点和上报、数据处理和数据分析。本文针对整个前端监控，设计适用的方案。本文的主要内容分为：")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("为什么需要前端监控")]),_._v(" "),t("li",[_._v("常用前端埋点方案总结")]),_._v(" "),t("li",[_._v("前端埋点方案选型和前端上报方案设计")]),_._v(" "),t("li",[_._v("前端监控结果可视化展示系统的设计")])])]),_._v(" "),t("h3",{attrs:{id:"一、为什么需要前端监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、为什么需要前端监控"}},[_._v("#")]),_._v(" 一、为什么需要前端监控")]),_._v(" "),t("p",[_._v("前端监控的目的是：")]),_._v(" "),t("p",[_._v("*"),t("strong",[_._v("获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向*")]),_._v("。")]),_._v(" "),t("p",[_._v("前端监控可以分为三类：数据监控、性能监控和异常监控。下面我们来一一的了解。")]),_._v(" "),t("h4",{attrs:{id:"_1-数据监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据监控"}},[_._v("#")]),_._v(" (1)数据监控")]),_._v(" "),t("p",[_._v("数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：")]),_._v(" "),t("ul",[t("li",[_._v("PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数")]),_._v(" "),t("li",[_._v("用户在每一个页面的停留时间")]),_._v(" "),t("li",[_._v("用户通过什么入口来访问该网页")]),_._v(" "),t("li",[_._v("用户在相应的页面中触发的行为")])]),_._v(" "),t("p",[_._v("统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。")]),_._v(" "),t("h4",{attrs:{id:"_2-性能监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-性能监控"}},[_._v("#")]),_._v(" (2)性能监控")]),_._v(" "),t("p",[_._v("性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：")]),_._v(" "),t("ul",[t("li",[_._v("不同用户，不同机型和不同系统下的首屏加载时间")]),_._v(" "),t("li",[_._v("白屏时间")]),_._v(" "),t("li",[_._v("http等请求的响应时间")]),_._v(" "),t("li",[_._v("静态资源整体下载时间")]),_._v(" "),t("li",[_._v("页面渲染时间")]),_._v(" "),t("li",[_._v("页面交互动画完成时间")])]),_._v(" "),t("p",[_._v("这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。")]),_._v(" "),t("h4",{attrs:{id:"_3-异常监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-异常监控"}},[_._v("#")]),_._v(" (3)异常监控")]),_._v(" "),t("p",[_._v("此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：")]),_._v(" "),t("ul",[t("li",[_._v("Javascript的异常监控")]),_._v(" "),t("li",[_._v("样式丢失的异常监控")])]),_._v(" "),t("h3",{attrs:{id:"二、常用前端埋点方案总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、常用前端埋点方案总结"}},[_._v("#")]),_._v(" 二、常用前端埋点方案总结")]),_._v(" "),t("p",[_._v("在上一节中介绍了前端监控的作用，那么如何实现前端监控呢，实现前端监控的步骤为：前端埋点和上报、数据处理和数据分析。首要的步骤就是前端埋点和上报，也就是数据的收集阶段。数据收集的丰富性和准确性会影响对产品线上效果的判别结果。")]),_._v(" "),t("p",[_._v("目前常见的前端埋点方法分为三种：代码埋点、可视化埋点和无痕埋点。下面一一介绍每一种埋点的方法。")]),_._v(" "),t("h4",{attrs:{id:"_1-代码埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-代码埋点"}},[_._v("#")]),_._v(" (1) 代码埋点")]),_._v(" "),t("p",[_._v("代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。")]),_._v(" "),t("p",[_._v("代码埋点的优点：")]),_._v(" "),t("ul",[t("li",[_._v("可以在任意时刻，精确的发送或保存所需要的数据信息。")])]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[_._v("工作量较大，每一个组件的埋点都需要添加相应的代码")])]),_._v(" "),t("h4",{attrs:{id:"_2-可视化埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-可视化埋点"}},[_._v("#")]),_._v(" (2)可视化埋点")]),_._v(" "),t("p",[_._v("通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。")]),_._v(" "),t("p",[_._v("可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[_._v("可视化埋点可以埋点的控件有限，不能手动定制。")])]),_._v(" "),t("h4",{attrs:{id:"_3-无埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-无埋点"}},[_._v("#")]),_._v(" (3)无埋点")]),_._v(" "),t("p",[_._v("无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。")]),_._v(" "),t("p",[_._v("从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点。")]),_._v(" "),t("p",[_._v("无埋点的优点：")]),_._v(" "),t("ul",[t("li",[_._v("由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象")])]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[_._v("无埋点采集全量数据，给数据传输和服务器增加压力")]),_._v(" "),t("li",[_._v("无法灵活的定制各个事件所需要上传的数据")])]),_._v(" "),t("h3",{attrs:{id:"三、前端埋点方案选型和前端上报方案设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、前端埋点方案选型和前端上报方案设计"}},[_._v("#")]),_._v(" 三、前端埋点方案选型和前端上报方案设计")]),_._v(" "),t("p",[_._v("第一章中介绍了前端所需要监听的信息，在第二章中介绍了前端埋点的常见方式，本文来根据需求，来定制我们的埋点和上报方案。")]),_._v(" "),t("h4",{attrs:{id:"_1-监控数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-监控数据"}},[_._v("#")]),_._v(" (1)监控数据")]),_._v(" "),t("p",[_._v("首先我们需要明确一个产品或者网页，普遍需要监控和上报的数据。监控的分为三个阶段：用户进入网页首页、用户在网页内部交互和交互中报错。每一个阶段需要监控和上报的数据如下图所示：")]),_._v(" "),t("p",[t("img",{attrs:{src:"eventTracking.assets/1460000015864673",alt:"default"}})]),_._v(" "),t("h4",{attrs:{id:"_2-埋点方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-埋点方案"}},[_._v("#")]),_._v(" (2)埋点方案")]),_._v(" "),t("p",[_._v("在实际项目中考虑到上报数据的灵活定制，以及减少数据传输和服务器的压力，在所需埋点处不多的情况下，常用的方式是代码埋点。")]),_._v(" "),t("p",[_._v("以用户进入首页为例，我们在首页渲染完成后会发送事件类型和类型相关的数据给server端，告知首页的监控信息。")]),_._v(" "),t("p",[t("img",{attrs:{src:"eventTracking.assets/1460000015864674",alt:"default"}})]),_._v(" "),t("h4",{attrs:{id:"_3-上报周期和上报数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-上报周期和上报数据类型"}},[_._v("#")]),_._v(" (3)上报周期和上报数据类型")]),_._v(" "),t("p",[_._v("如果埋点的事件不是很多，上报可以时时进行，比如监控用户的交互事件，可以在用户触发事件后，立刻上报用户所触发的事件类型。如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。")]),_._v(" "),t("p",[_._v("接着来确定需要埋点上报的数据，上报的信息包括用户个人信息以及用户行为，主要数据可以分为：")]),_._v(" "),t("ul",[t("li",[_._v("who: appid(系统或者应用的id),userAgent(用户的系统、网络等信息)")]),_._v(" "),t("li",[_._v("when: timestamp(上报的时间戳)")]),_._v(" "),t("li",[_._v("from where: currentUrl(用户当前url)，fromUrl(从哪一个页面跳转到当前页面)，type(上报的事件类型),element(触发上报事件的元素）")]),_._v(" "),t("li",[_._v("what: 上报的自定义扩展数据data:{},扩展数据中可以按需求定制，比如包含uid等信息")])]),_._v(" "),t("p",[_._v("上报数据的对象为：")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("{   \n    ----------------上报接口本身提供--------------------\n    currentUrl,  \n    fromUrl,\n    timestamp,\n    userAgent:{\n       os,\n       netWord,\n    }\n    ----------------业务代码配置和自定义上报数据------------\n    type,\n    appid,\n    element,\n    data:{\n        uid,\n        uname\n    }\n}\n")])])]),t("h4",{attrs:{id:"_4-埋点和上报举例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-埋点和上报举例"}},[_._v("#")]),_._v(" (4)埋点和上报举例")]),_._v(" "),t("p",[_._v("我们以上报首屏加载事件为例，DOM提供了document的DOMContentLoaded事件来监听dom挂载，提供了window的load事件来监听页面所有资源加载渲染完毕。")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("<script type=\"text/javascript\">\n  var start=Date.now();\n  document.addEventListener('DOMContentLoaded', function() {\n     fetch('some api',{\n         type:'dom complete',\n         data:{\n           domCompletedTime:Date.now()-start\n         }\n     })\n  });\n  window.addEventListener('load', function() {\n     fetch('some api',{\n         type:'load complete',\n         data:{\n           LoadCompletedTime:Date.now()-start\n         }\n     })\n  });\n<\/script>\n")])])]),t("h4",{attrs:{id:"_5-前端埋点系统的前后端通信加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-前端埋点系统的前后端通信加密"}},[_._v("#")]),_._v(" (5)前端埋点系统的前后端通信加密")]),_._v(" "),t("p",[_._v("在上报数据的前后端通信中，需要和server端协商加密机制，利用 OpenSSL库来实现的加密，OpenSSL已经是一个广泛被采用的加密算法。前端可以采用node的crypto模块。")]),_._v(" "),t("p",[_._v("首先来看hash算法，crypto.createHash() 来创建一个Hash实例，可利用的hash算法如下：")]),_._v(" "),t("ul",[t("li",[_._v("md5")]),_._v(" "),t("li",[_._v("sha1")]),_._v(" "),t("li",[_._v("sha256")]),_._v(" "),t("li",[_._v("sha512")]),_._v(" "),t("li",[_._v("ripemd160")])]),_._v(" "),t("p",[_._v("以sha256算法加密为例：")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("const str=\"123445\";//需要加密的字段\nconst hash=crypto.createHash('sha256');//指定加密算法\nhash.update(str); //通过算法加密相应的字段\nconst result=hash.digest('hex');//转化成十六进制\n")])])]),t("h3",{attrs:{id:"四、前端监控结果可视化展示系统的设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、前端监控结果可视化展示系统的设计"}},[_._v("#")]),_._v(" 四、前端监控结果可视化展示系统的设计")]),_._v(" "),t("p",[_._v("当后端得到前端上报的信息之后，经过数据分析和处理，需要前端可视化的展示数据分析后的结果。")]),_._v(" "),t("p",[_._v("可以在开源中后台系统ant-design-pro的基础上进行二次开发，首先要明确展示信息。展示的信息包括单个用户和整体应用。")]),_._v(" "),t("p",[_._v("对于单个用户来说需要展示的监控信息为：")]),_._v(" "),t("ul",[t("li",[_._v("单个用户，在交互过程中触发各个埋点事件的次数")]),_._v(" "),t("li",[_._v("单个用户，在某个时间周期内，访问本网页的入口来源")]),_._v(" "),t("li",[_._v("单个用户，在每一个子页面的停留时间")])]),_._v(" "),t("p",[_._v("对于全体用户需要展示的信息为：")]),_._v(" "),t("ul",[t("li",[_._v("某一个时间段内网页的PV和UV")]),_._v(" "),t("li",[_._v("全体用户访问网页的设备和操作系统分析")]),_._v(" "),t("li",[_._v("某一个时间段内访问本网页的入口来源分析")]),_._v(" "),t("li",[_._v("全体用户在访问本网页时，在交互过程中触发各个埋点事件的总次数")]),_._v(" "),t("li",[_._v("全体用户在访问本网页时，网页上报异常的集合")])]),_._v(" "),t("p",[_._v("删选功能集合：")]),_._v(" "),t("ul",[t("li",[_._v("时间筛选：提供今日（00点到当前时间）、本周、本月和全年")]),_._v(" "),t("li",[_._v("用户删选：提供根据用户id删选出用户行为的统计信息")]),_._v(" "),t("li",[_._v("设备删选：删选不同系统的整体展示信息")])])])}),[],!1,null,null,null);v.default=s.exports}}]);