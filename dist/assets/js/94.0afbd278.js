(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{608:function(a,s,t){"use strict";t.r(s);var _=t(6),v=Object(_.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"语义分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语义分析"}},[a._v("#")]),a._v(" 语义分析")]),a._v(" "),t("h2",{attrs:{id:"控制流语句-if-和-while-语句的翻译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制流语句-if-和-while-语句的翻译"}},[a._v("#")]),a._v(" 控制流语句 if 和 while 语句的翻译")]),a._v(" "),t("p",[a._v("将 if 和 while 语句翻译成四元式")]),a._v(" "),t("p",[a._v("注：不同教材会有小差异，使用 _ 或者 — ，如果是 —，请注意区分 — 和 - 减号")]),a._v(" "),t("h3",{attrs:{id:"一-四元式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-四元式"}},[a._v("#")]),a._v(" （一）四元式")]),a._v(" "),t("p",[a._v("四元式是普遍采用的一种中间代码形式，由于它便于优化处理，所以目前在很多编译程序中得到广泛应用。")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("形式")]),a._v(" "),t("th",[a._v("表示")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("一般形式")]),a._v(" "),t("td",[a._v("（op ，arg1 ，arg2 ，result）")])]),a._v(" "),t("tr",[t("td",[a._v("一目运算")]),a._v(" "),t("td",[a._v("（op ，arg1 ，____ ，result）")])]),a._v(" "),t("tr",[t("td",[a._v("0元运算")]),a._v(" "),t("td",[a._v("（op ，____ ，____，result）")])])])]),a._v(" "),t("p",[t("strong",[a._v("如：a:= -b+c*d的四元式为：")])]),a._v(" "),t("p",[a._v("（:= 表示赋值，用于区分 =）")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("(1) ( - , b , __ , T1 )\n(2) ( * , c , d , T2 )\n(3) ( + , T1 , T2 , T3 )\n(4) ( := , T3 , __ , a )")])])]),a._v(" "),t("p",[a._v("T1 := -b\nT2 := c * d\nT3 := T1 + T2\na : = T3")]),a._v(" "),t("p",[t("strong",[a._v("四元式的最大优点：")])]),a._v(" "),t("p",[a._v("在实现代码优化时，通常需要从现有的运算序列删去某些运算，或者需要挪动一些运算的位置，这对于四元式序列来说，是比较容易实现的。")]),a._v(" "),t("p",[a._v("因为四元式之间的联系是通过临时变量来实现的，所以更改其中一些四元式给整个序列带来的影响较小")]),a._v(" "),t("h3",{attrs:{id:"二-if-语句的翻译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-if-语句的翻译"}},[a._v("#")]),a._v(" （二）if 语句的翻译")]),a._v(" "),t("p",[a._v("描述 if 语句的文法如下：")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("if E then S1")])])]),a._v(" "),t("p",[a._v("或者")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("if E then S1 else S2")])])]),a._v(" "),t("p",[a._v("其中 E 为布尔表达式\nS1，S2 本身也可以是 if 语句或者其他语句")]),a._v(" "),t("h4",{attrs:{id:"控制语句中的回填技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制语句中的回填技术"}},[a._v("#")]),a._v(" 控制语句中的回填技术")]),a._v(" "),t("p",[a._v("一些转移地址并不能不产生这些四元式的同时得知。")]),a._v(" "),t("p",[a._v("也就是说，一个布尔式的真假出口往往不能在产生四元式的同时就确定。\n因此，要回填这些地址")]),a._v(" "),t("h4",{attrs:{id:"拉链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拉链"}},[a._v("#")]),a._v(" 拉链")]),a._v(" "),t("p",[a._v("为了记录需回填地址的四元式，采用 “拉链” 的方法。")]),a._v(" "),t("p",[a._v("把需回填 E.true 的四元式拉成一链，把需回填 E.false 的四元式拉成一链，分别称做“真”链和“假”链")]),a._v(" "),t("h4",{attrs:{id:"if-语句翻译过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#if-语句翻译过程"}},[a._v("#")]),a._v(" IF 语句翻译过程")]),a._v(" "),t("p",[a._v("IF 语句翻译过程大致如下：")]),a._v(" "),t("p",[a._v("(1) 翻译 E，获得一组四元式；\n(2) 扫描 E 的真出口，回填；\n假出口尚不知；\n(3) 翻译 S(1) ；\n(4) 遇到 else，S(1) 结束，生成一条无条件转移四元式，但出口不明；\n(5) 翻译 S(2) ，结束。")]),a._v(" "),t("h4",{attrs:{id:"if-语句的翻译例题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#if-语句的翻译例题"}},[a._v("#")]),a._v(" if 语句的翻译例题：")]),a._v(" "),t("p",[a._v("对下语句进行翻译：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("A")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),a._v(" or "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),a._v(" then\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("D")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("E")]),a._v(" then "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("F")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("F")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" \n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("F")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("F")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("F")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("四元式从 100 开始编号：")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("100 ( j> , A , B , 104 )\n101 ( j , _ , _ , 102 )\n102 ( jnz, C , _ , 104 )\n103 ( j , _ , _ , 112 )\n104 ( j< , D , E , 106 )\n105 ( j , _ , _ , 109 )\n106 ( + , F , 1 , T1 )\n107 ( := , T1 , _ , F )\n108 ( j , _ , _ , 113 )\n109 ( - , F , 1 , T2 )\n110 ( := , T2 , _ , F)\n111 ( j , _ , _ , 113 )\n112 ( := , 0 , _ , F )\n113 ...")])])]),a._v(" "),t("p",[t("strong",[a._v("解释：")])]),a._v(" "),t("p",[a._v("（1）第 100 号 ( j> , A , B , 104 ) ，表式示如果满足 A > B，此时四元式第四个表示结果的是 104，就表示跳转到 104 号执行，是一个真出口；如果不满足就会继续走到下个序号的四元式 101 号。\n（2）第 101 号 ( j , _ , _ , 102 )，表示直接到 102。虽然没有这一句也能到达 102，但是它表表示上面不满足的状态，也叫假出口，必须要写。\n（3）所以写条件要一写一对，因为不满足就走到下一个序号的四元式，并且假出口只能在它相邻的下面。\n（4）第 102 号 ( jnz, C , _ , 104 )，只有一个参数，操作符时 jnz，然后同样是满足则到 104，不满足走到下一个序号的四元式。\n（5）第 106 号 ( + , F , 1 , T1 )，T1 是 F + 1 的结果，此时不表示跳转，不跳转也就是走到下个序号的四元式。\n（6）注意赋值语句的表示，第 107 号 ( := , T1 , _ , F )，是将被赋值的元素放在结果的位置上，就是四元式第四个位置。")]),a._v(" "),t("h3",{attrs:{id:"三-while-语句的翻译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-while-语句的翻译"}},[a._v("#")]),a._v(" （三）while 语句的翻译")]),a._v(" "),t("h4",{attrs:{id:"while-语句的翻译过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#while-语句的翻译过程"}},[a._v("#")]),a._v(" while 语句的翻译过程")]),a._v(" "),t("p",[a._v("while 语句的翻译过程大致如下：\n(1) 翻译 E，待填 E 的真链、假链；\n(2) 扫描 do 后，回填 E 的真链；\n(3) 翻译 S 语句称代码段；\n(4) 无条件转移到 E 代码段的第一条四元式，若 S 有语句链，也应转到 E 代码段的第一条四元式。")]),a._v(" "),t("h4",{attrs:{id:"while-语句的翻译例题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#while-语句的翻译例题"}},[a._v("#")]),a._v(" while 语句的翻译例题")]),a._v(" "),t("p",[a._v("对下语句进行翻译：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("While")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  b"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("b"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("四元式从 100 开始编号：")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("101 (j<, a, b, 103) 真出口\n102 (j, _ , _ , 108) 假出口\n103 (+, a, 3, T1)\n104 (:=, T1, _ , a)\n105 (-, b, 3, T2)\n106 (:=, T2, _ , b)\n107 (j, _ , _ , 101)\n108 ...")])])]),a._v(" "),t("p",[t("strong",[a._v("解释：")])]),a._v(" "),t("p",[a._v("（1）原理同上\n（2）注意赋值语句的表示，例如第 104 号 (:=, T1, _, a)，是将被赋值的元素放在结果的位置上，就是四元式第四个位置。")]),a._v(" "),t("h2",{attrs:{id:"画-dag-图与求优化后的-4-元式代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#画-dag-图与求优化后的-4-元式代码"}},[a._v("#")]),a._v(" 画 DAG 图与求优化后的 4 元式代码")]),a._v(" "),t("p",[a._v("DAG 图（Directed Acylic Graph）无环路有向图")]),a._v(" "),t("h4",{attrs:{id:"一-基本块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-基本块"}},[a._v("#")]),a._v(" （一）基本块")]),a._v(" "),t("p",[a._v("基本块是指程序中一顺序执行的语句序列，其中只有一个入口语句（第一个语句）和一个出口语句（最后一个语句）")]),a._v(" "),t("p",[a._v("对于一个基本块来说，执行时只能从其入口语句进入，从其出口语句退出")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("语句")]),a._v(" "),t("th")])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("出口语句")]),a._v(" "),t("td",[a._v("任何控制转移四元式")])]),a._v(" "),t("tr",[t("td",[a._v("入口语句")]),a._v(" "),t("td",[a._v("所转向的目标语句")])])])]),a._v(" "),t("h4",{attrs:{id:"二-划分基本块的步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-划分基本块的步骤"}},[a._v("#")]),a._v(" （二）划分基本块的步骤")]),a._v(" "),t("p",[a._v("1、求四元式序列中各个基本块的入口语句。")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("① 程序的第一个语句")])]),a._v(" "),t("li",[t("strong",[a._v("② 能由条件或无条件转移语句转移到的语句")])]),a._v(" "),t("li",[t("strong",[a._v("③ 紧跟在条件转移语句后面的语句")])])]),a._v(" "),t("p",[a._v("2、对每一入口语句，构造所属的基本块，该基本块由：")]),a._v(" "),t("ul",[t("li",[a._v("1）该入口语句到下一入口语句（不包括下一入口语句）之间的语句序列组成")]),a._v(" "),t("li",[a._v("2）该入口语句到一转移语句（包括该转移语句）之间的语句序列组成")]),a._v(" "),t("li",[a._v("3）该入口语句到一停语句（包括该停语句）之间的语句序列组成")])]),a._v(" "),t("p",[a._v("3、凡是未包含在某一基本块中的语句，都是程序中控制流程不可达的语句，可删除它们。")]),a._v(" "),t("h5",{attrs:{id:"例题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例题"}},[a._v("#")]),a._v(" 例题：")]),a._v(" "),t("p",[a._v("对于下面给出的求最大公因子的程序，可以根据基本块的构造规则与其划分基本块")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/CSBase/Complier/semanticAnalysis.assets/1483449-20190623162307971-777419437.png",alt:"img"}})]),a._v(" "),t("p",[t("strong",[a._v("基本块构造步骤：")])]),a._v(" "),t("p",[a._v("（1）：由规则 (1) 中的 ① 可知语句 (1) 是一个入口语句\n（2）：由规则 (1) 中的 ② 可知，语句 (3) 和 (8) 均是人口语句\n（3）：由规则 (1) 中的 ③ 可知，语句 (5) 是二个人口语句，可以用 “+” 在人口语句的左侧作标记。\n（4）：由规则 (2) 可以划分该程序为四个基本块，它们分别是：")]),a._v(" "),t("ul",[t("li",[a._v("语句 (1)、(2) 组成的基本块 B1")]),a._v(" "),t("li",[a._v("语句 (3)、(4) 组成的基本块 B2")]),a._v(" "),t("li",[a._v("语句 (5)、(6) 和 (7) 组成的基本块 B3")]),a._v(" "),t("li",[a._v("语句 (8) .(9) 组成的基本块 B4")])]),a._v(" "),t("p",[a._v("程序中在代码段左侧对各个基本块进行了标记。")]),a._v(" "),t("h4",{attrs:{id:"三-程序控制流程流图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-程序控制流程流图"}},[a._v("#")]),a._v(" （三）程序控制流程流图")]),a._v(" "),t("p",[t("strong",[a._v("定义：")]),a._v(" 以基本块为结点，控制程序流向作为有向边，画出的有向图称为流图。")]),a._v(" "),t("p",[t("strong",[a._v("特点：")])]),a._v(" "),t("ul",[t("li",[a._v("具有唯一首结点的有向图")]),a._v(" "),t("li",[a._v("从首结点开始到流图中任何结点都有通路")])]),a._v(" "),t("p",[a._v("如果一个结点的基本块的入口语句是程序的第一条语句，则称此结点为首结点")]),a._v(" "),t("h5",{attrs:{id:"程序控制流程流图的表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序控制流程流图的表示"}},[a._v("#")]),a._v(" 程序控制流程流图的表示")]),a._v(" "),t("p",[a._v("一个控制流程图可表示成一个三元组：\nG=(N，E，n0 )")]),a._v(" "),t("p",[a._v("N：所有结点(基本块)集；\nE：所有有向边集；\nn0 ：首结点。")]),a._v(" "),t("p",[t("strong",[a._v("有向边：")])]),a._v(" "),t("p",[a._v("当下述条件有一个成立时，从结点i有一有向边引向结点 j：")]),a._v(" "),t("ul",[t("li",[a._v("① 基本块 j 在程序的位置紧跟在i后，且 i 的出口语句不是无条件转移或停语句")]),a._v(" "),t("li",[a._v("② i 的出口是 goto(S) 或 if goto(S)，而 (S) 是 j 的入口语句")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/CSBase/Complier/semanticAnalysis.assets/1483449-20190623162326237-100769702.png",alt:"img"}})]),a._v(" "),t("h5",{attrs:{id:"构造程序控制流图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造程序控制流图"}},[a._v("#")]),a._v(" 构造程序控制流图")]),a._v(" "),t("p",[a._v("对程序基本块：")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/CSBase/Complier/semanticAnalysis.assets/1483449-20190623162307971-777419437.png",alt:"img"}})]),a._v(" "),t("p",[a._v("构造以下程序控制流图：")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/CSBase/Complier/semanticAnalysis.assets/1483449-20190623162226499-393249664.png",alt:"img"}})]),a._v(" "),t("h4",{attrs:{id:"四-基本块的-dag-表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-基本块的-dag-表示"}},[a._v("#")]),a._v(" （四）基本块的 DAG 表示")]),a._v(" "),t("p",[a._v("DAG Directed Acyclic Graph 无环路有向图")]),a._v(" "),t("p",[t("strong",[a._v("定义：")])]),a._v(" "),t("p",[a._v("(1) 在一个有向图中，若结点 ni 有弧指向结点 nj，则 ni 是 nj 的父结点，nj 是 ni 的子结点；\n(2) 若 n1,n2,…,nk 间存在有向弧 n1→n2→…→nk，则称 n1 到 nk 之间存在一条通路，若有 nk=n1，则称该通路为环路；\n(3) 若有向图中任意通路都不是环路，则称该图为无环路有向图（DAG）")]),a._v(" "),t("p",[t("strong",[a._v("用来描述基本块的 DAG：")])]),a._v(" "),t("p",[a._v("(1) 图的叶结点以一标识符或常数做标记，表示该结点代表该变量或常数的值。\n(2) 图的内部结点以一运算符作为标记；\n(3) 图中各个结点上可能附加一个或多个标识符，表示这些标识符具有该结点所代表的值，简称附标。")]),a._v(" "),t("p",[t("strong",[a._v("四元式对应的 DAG 结点形式")])]),a._v(" "),t("p",[a._v("按其四元式对应结点的后继个数分成四种类型：0型、1型、2型、3型")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/CSBase/Complier/semanticAnalysis.assets/1483449-20190623162214686-48646760.png",alt:"img"}})]),a._v(" "),t("h4",{attrs:{id:"五-dag-图构造例题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五-dag-图构造例题"}},[a._v("#")]),a._v(" （五）DAG 图构造例题")]),a._v(" "),t("p",[a._v("对于基本块 P")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("（1）S0 := 2\n（2）S4 := 2\n（3）S1 := 1.5\n（4）S2 := T-C\n（5）S3 := T+C\n（6）S5 := S3\n（7）R := 2/S3\n（8）S6 := R\n（9）H := R*S2")])])]),a._v(" "),t("p",[a._v("（1）试用 DAG 进行优化并重写基本块\n（2）假定只有 R，H 在基本块出口是活跃的，试写出优化后的 4 元式序列\n（只需要还原活跃变量）")]),a._v(" "),t("h5",{attrs:{id:"解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[a._v("#")]),a._v(" 解析：")]),a._v(" "),t("p",[t("strong",[a._v("（1）画出 DAG 图如下：")])]),a._v(" "),t("p",[a._v("画图的步骤就是：根据基本块，一部一部组装")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/CSBase/Complier/semanticAnalysis.assets/1483449-20190623162154304-133699150.png",alt:"img"}})]),a._v(" "),t("p",[t("strong",[a._v("（2）假定只有 R，H 在基本块出口是活跃的，试写出优化后的 4 元式序列\n（只需要还原活跃变量）")])]),a._v(" "),t("p",[a._v("优化后的 4 元式代码可以写为：\n（1）S2 := T-C\n（2）S3 := T+C\n（3）R := 2/S3\n（4）H := R*S2")]),a._v(" "),t("p",[t("strong",[a._v("解释：")])]),a._v(" "),t("p",[a._v("与原来的基本块相比较可以看出：")]),a._v(" "),t("ul",[t("li",[a._v("原基本块中的 (2) 和 (7) 中的已知量都已经合并。因为 (2) 中 S4 := 2，(7) 中用 2，所以合并。")]),a._v(" "),t("li",[a._v("(5) 和 (8) 中的公共子表达式 T+C 只在 (5) 中计算一次，在 (8) 中 直接引用其结果，所以删除了多余运算。")]),a._v(" "),t("li",[a._v("(6) 中的无用赋值已被删除。S5 := S3，S5 后面没有再用，所以就和 S3 一起表示。")])]),a._v(" "),t("p",[a._v("除了可以应用 DAG 进行上述的优化外，还可以从基本块的 DAG 中得到一些其他信息：")]),a._v(" "),t("ul",[t("li",[a._v("DAG 叶结点上标记的标识符是在该基本块之前的基本块内被定值，并在该基本块内被引用的标识符。")]),a._v(" "),t("li",[a._v("DAG 各结点上的附加标识符是在基本块内被定值，并可以在基本块后被引用的标识符。")])]),a._v(" "),t("p",[a._v("如果确认某结点的一个附加标记在基本块后不会被引用，则该标识符的定值语句可以作为死代码被删除。")]),a._v(" "),t("p",[a._v("假设上面例子中 S0~S6。在基本块后面都不会被引用只有 R, H 在基本块出口是活跃的则优化后的四元式序列可以写为：\n（1）S2 := T-C\n（2）S3 := T+C\n（3）R := 2/S3\n（4）H := R*S2")])])}),[],!1,null,null,null);s.default=v.exports}}]);