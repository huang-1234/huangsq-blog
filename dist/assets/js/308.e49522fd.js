(window.webpackJsonp=window.webpackJsonp||[]).push([[308],{814:function(r,e,t){"use strict";t.r(e);var n=t(6),o=Object(n.a)({},(function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"_1-render-stage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-render-stage"}},[r._v("#")]),r._v(" 1-render-stage")]),r._v(" "),t("h2",{attrs:{id:"beginwork"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#beginwork"}},[r._v("#")]),r._v(" beginWork")]),r._v(" "),t("p",[r._v("学习后续的 render 阶段和 commit 阶段。这其中，render 阶段可以认为是整个渲染链路中最为核心的一环，因为我们反复强调“找不同”的过程，恰恰就是在这个阶段发生的。")]),r._v(" "),t("p",[r._v("render 阶段做的事情有很多，这里我们将以 beginWork 为线索，着重探讨 Fiber 树的构建过程。")]),r._v(" "),t("p",[r._v("performSyncWorkOnRoot 标志着 render 阶段的开始，finishSyncRender 标志着 render 阶段的结束。这中间包含了大量的 beginWork、completeWork 调用栈，正是 render 的工作内容。")]),r._v(" "),t("p",[r._v("beginWork、completeWork 这两个方法需要注意，它们串联起的是一个“模拟递归”的过程。")]),r._v(" "),t("p",[r._v("在前面我强调过，React 15 下的调和过程是一个递归的过程。而 Fiber 架构下的调和过程，虽然并不是依赖递归来实现的，但在")]),r._v(" "),t("p",[r._v("ReactDOM.render 触发的同步模式下，它仍然是一个深度优先搜索的过程。在这个过程中，beginWork 将创建新的 Fiber 节点，而 completeWork 则负责将 Fiber 节点映射为 DOM 节点。")]),r._v(" "),t("h2",{attrs:{id:"workinprogress-节点的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workinprogress-节点的创建"}},[r._v("#")]),r._v(" workInProgress 节点的创建")]),r._v(" "),t("p",[r._v("前一章曾经提到，performSyncWorkOnRoot  是 render 阶段的起点，而这个函数最关键的地方在于它调用了 renderRootSync。")])])}),[],!1,null,null,null);e.default=o.exports}}]);