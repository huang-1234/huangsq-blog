(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{389:function(t,v,e){"use strict";e.r(v);var s=e(45),_=Object(s.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器多进程多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器多进程多线程"}},[t._v("#")]),t._v(" 浏览器多进程多线程")]),t._v(" "),e("h2",{attrs:{id:"梳理主干流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#梳理主干流程"}},[t._v("#")]),t._v(" 梳理主干流程")]),t._v(" "),e("p",[t._v("回到这道题上，如何回答呢？先梳理一个骨架")]),t._v(" "),e("p",[t._v("知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）\n\n2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）\n\n3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）\n\n4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）\n\n5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）\n\n6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）\n\n7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）\n\n8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）\n\n9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）\n")])])]),e("p",[t._v("梳理出主干骨架，然后就需要往骨架上填充细节内容")]),t._v(" "),e("h2",{attrs:{id:"从浏览器接收url到开启网络请求线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从浏览器接收url到开启网络请求线程"}},[t._v("#")]),t._v(" 从浏览器接收url到开启网络请求线程")]),t._v(" "),e("p",[t._v("这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制")]),t._v(" "),e("h3",{attrs:{id:"多进程的浏览器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多进程的浏览器"}},[t._v("#")]),t._v(" 多进程的浏览器")]),t._v(" "),e("p",[t._v("浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）")]),t._v(" "),e("p",[t._v("进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等")]),t._v(" "),e("ul",[e("li",[t._v("Browser进程：浏览器的主进程（负责协调、主控），只有一个")]),t._v(" "),e("li",[t._v("第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建")]),t._v(" "),e("li",[t._v("GPU进程：最多一个，用于3D绘制")]),t._v(" "),e("li",[t._v("浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）")])]),t._v(" "),e("p",[t._v("如下图：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/BrowserModel/BrowserArch//images/BrowserModel/BrowserArch/BrowserMutilProcessMutilThread.assets/browser_process_list2.png",alt:"img"}})]),t._v(" "),e("h3",{attrs:{id:"多线程的浏览器内核"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程的浏览器内核"}},[t._v("#")]),t._v(" 多线程的浏览器内核")]),t._v(" "),e("p",[t._v("每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("GUI线程")])]),t._v(" "),e("li",[e("p",[t._v("JS引擎线程")])]),t._v(" "),e("li",[e("p",[t._v("事件触发线程")])]),t._v(" "),e("li",[e("p",[t._v("定时器线程")])]),t._v(" "),e("li",[e("p",[t._v("网络请求线程")]),t._v(" "),e("h3",{attrs:{id:"本文重点-多进程浏览器架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本文重点-多进程浏览器架构"}},[t._v("#")]),t._v(" 本文重点 - 多进程浏览器架构")]),t._v(" "),e("p",[t._v("不扯以前的旧的浏览器架构，Chrome 浏览器的架构如下图所示（不一定最新）。"),e("strong",[t._v("需要注意的是，像 UI process, Network process 等等这些进程都有可能会被“降级”为 Browser process 的线程（UI thread, Network thread）")]),t._v("。")]),t._v(" "),e("blockquote",[e("p",[t._v("When Chrome is running on powerful hardware, it may split each service into different processes giving more stability, but if it is on a resource-constraint device, Chrome consolidates services into one process saving memory footprint.")])])])]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/BrowserModel/BrowserArch/BrowserMutilProcessMutilThread.assets/BrowserMultiProcess.jpg",alt:"img"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/BrowserModel/BrowserArch/BrowserMutilProcessMutilThread.assets/browser_inner_thread.png",alt:"img"}}),t._v(" "),e("img",{attrs:{src:"/images/BrowserModel/BrowserArch/BrowserMutilProcessMutilThread.assets/RenderingProcess.jpg",alt:"img"}})]),t._v(" "),e("p",[t._v("可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的")]),t._v(" "),e("h3",{attrs:{id:"解析url"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析url"}},[t._v("#")]),t._v(" 解析URL")]),t._v(" "),e("p",[t._v("输入URL后，会进行解析（URL的本质就是统一资源定位符）")]),t._v(" "),e("p",[t._v("URL一般包括几大部分：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("protocol")]),t._v("，协议头，譬如有http，ftp等")]),t._v(" "),e("li",[e("code",[t._v("host")]),t._v("，主机域名或IP地址")]),t._v(" "),e("li",[e("code",[t._v("port")]),t._v("，端口号")]),t._v(" "),e("li",[e("code",[t._v("path")]),t._v("，目录路径")]),t._v(" "),e("li",[e("code",[t._v("query")]),t._v("，即查询参数")]),t._v(" "),e("li",[e("code",[t._v("fragment")]),t._v("，即"),e("code",[t._v("#")]),t._v("后的hash值，一般用来定位到某个位置")])]),t._v(" "),e("h3",{attrs:{id:"网络请求都是单独的线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络请求都是单独的线程"}},[t._v("#")]),t._v(" 网络请求都是单独的线程")]),t._v(" "),e("p",[t._v("每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载")]),t._v(" "),e("p",[t._v("因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）")]),t._v(" "),e("h3",{attrs:{id:"更多"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更多"}},[t._v("#")]),t._v(" 更多")]),t._v(" "),e("p",[t._v("由于篇幅关系，这里就大概介绍一个主干流程，关于浏览器的进程机制，更多可以参考以前总结的一篇文章（因为内容实在过多，里面包括JS运行机制，进程线程的详解）")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000012925872",target:"_blank",rel:"noopener noreferrer"}},[t._v("从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"开启网络线程到发出一个完整的http请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开启网络线程到发出一个完整的http请求"}},[t._v("#")]),t._v(" 开启网络线程到发出一个完整的http请求")]),t._v(" "),e("p",[t._v("这一部分主要内容包括："),e("code",[t._v("dns")]),t._v("查询，"),e("code",[t._v("tcp/ip")]),t._v("请求构建，"),e("code",[t._v("五层因特网协议栈")]),t._v("等等")]),t._v(" "),e("p",[t._v("仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）")]),t._v(" "),e("h3",{attrs:{id:"dns查询得到ip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns查询得到ip"}},[t._v("#")]),t._v(" DNS查询得到IP")]),t._v(" "),e("p",[t._v("如果输入的是域名，需要进行dns解析成IP，大致流程：")]),t._v(" "),e("ul",[e("li",[t._v("如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host")]),t._v(" "),e("li",[t._v("如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP")])]),t._v(" "),e("p",[t._v("注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）")]),t._v(" "),e("p",[t._v("而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑"),e("code",[t._v("dns-prefetch")]),t._v("优化")]),t._v(" "),e("p",[t._v("这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）")]),t._v(" "),e("h3",{attrs:{id:"tcp-ip请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip请求"}},[t._v("#")]),t._v(" tcp/ip请求")]),t._v(" "),e("p",[t._v("http的本质就是"),e("code",[t._v("tcp/ip")]),t._v("请求")]),t._v(" "),e("p",[t._v("需要了解3次握手规则建立连接以及断开连接时的四次挥手")]),t._v(" "),e("p",[t._v("tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输")]),t._v(" "),e("p",[e("strong",[t._v("三次握手的步骤：（抽象派）")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("客户端：hello，你是server么？\n服务端：hello，我是server，你是client么\n客户端：yes，我是client\n")])])]),e("p",[t._v("建立连接成功后，接下来就正式传输数据")]),t._v(" "),e("p",[t._v("然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）")]),t._v(" "),e("p",[e("strong",[t._v("四次挥手的步骤：（抽象派）")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n被动方：收到通道关闭的信息\n被动方：那我也告诉你，我这边向你的主动通道也关闭了\n主动方：最后收到数据，之后双方无法通信\n")])])]),e("p",[e("strong",[t._v("tcp/ip的并发限制")])]),t._v(" "),e("p",[t._v("浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）")]),t._v(" "),e("p",[t._v("而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求")]),t._v(" "),e("p",[t._v("所以针对这个瓶颈，又出现了很多的资源优化方案")]),t._v(" "),e("p",[e("strong",[t._v("get和post的区别")])]),t._v(" "),e("p",[t._v("get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。")]),t._v(" "),e("p",[t._v("get会产生一个tcp数据包，post两个")]),t._v(" "),e("p",[t._v("具体就是：")]),t._v(" "),e("ul",[e("li",[t._v("get请求时，浏览器会把"),e("code",[t._v("headers")]),t._v("和"),e("code",[t._v("data")]),t._v("一起发送出去，服务器响应200（返回数据），")]),t._v(" "),e("li",[t._v("post请求时，浏览器先发送"),e("code",[t._v("headers")]),t._v("，服务器响应"),e("code",[t._v("100 continue")]),t._v("， 浏览器再发送"),e("code",[t._v("data")]),t._v("，服务器响应200（返回数据）。")])]),t._v(" "),e("p",[t._v("再说一点，这里的区别是"),e("code",[t._v("specification")]),t._v("（规范）层面，而不是"),e("code",[t._v("implementation")]),t._v("（对规范的实现）")]),t._v(" "),e("h3",{attrs:{id:"五层因特网协议栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五层因特网协议栈"}},[t._v("#")]),t._v(" 五层因特网协议栈")]),t._v(" "),e("p",[t._v("其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念")]),t._v(" "),e("p",[t._v("其实就是一个概念： "),e("strong",[t._v("从客户端发出http请求到服务器接收，中间会经过一系列的流程。")])]),t._v(" "),e("p",[t._v("简括就是：")]),t._v(" "),e("p",[e("strong",[t._v("从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。")])]),t._v(" "),e("p",[t._v("当然，服务端的接收就是反过来的步骤")]),t._v(" "),e("p",[t._v("五层因特网协议栈其实就是：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1.应用层(dns,http) DNS解析成IP并发送http请求\n\n2.传输层(tcp,udp) 建立tcp连接（三次握手）\n\n3.网络层(IP,ARP) IP寻址\n\n4.数据链路层(PPP) 封装成帧\n\n5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）\n")])])]),e("p",[t._v("当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。")]),t._v(" "),e("p",[t._v("OSI七层框架："),e("code",[t._v("物理层")]),t._v("、"),e("code",[t._v("数据链路层")]),t._v("、"),e("code",[t._v("网络层")]),t._v("、"),e("code",[t._v("传输层")]),t._v("、"),e("code",[t._v("会话层")]),t._v("、"),e("code",[t._v("表示层")]),t._v("、"),e("code",[t._v("应用层")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等\n\n会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程\n")])])]),e("h2",{attrs:{id:"从服务器接收到请求到对应后台接收到请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从服务器接收到请求到对应后台接收到请求"}},[t._v("#")]),t._v(" 从服务器接收到请求到对应后台接收到请求")])])}),[],!1,null,null,null);v.default=_.exports}}]);