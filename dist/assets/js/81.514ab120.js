(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{436:function(t,e,a){"use strict";a.r(e);var s=a(45),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),a("h2",{attrs:{id:"redux-介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-介绍"}},[t._v("#")]),t._v(" Redux 介绍")]),t._v(" "),a("blockquote",[a("p",[t._v("本文主要是对 "),a("a",{attrs:{href:"http://rackt.github.io/redux/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux 官方文档"),a("OutboundLink")],1),t._v(" 的梳理以及自身对 Redux 的理解。")])]),t._v(" "),a("h3",{attrs:{id:"单页面应用的痛点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单页面应用的痛点"}},[t._v("#")]),t._v(" 单页面应用的痛点")]),t._v(" "),a("p",[t._v("对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。")]),t._v(" "),a("p",[t._v("Redux 就是用来确保 state 变化的可预测性，主要的约束有：")]),t._v(" "),a("ul",[a("li",[t._v("state 以单一对象存储在 store 对象中")]),t._v(" "),a("li",[t._v("state 只读")]),t._v(" "),a("li",[t._v("使用纯函数 reducer 执行 state 更新")])]),t._v(" "),a("blockquote",[a("p",[t._v("state 为单一对象，使得 Redux 只需要维护一棵状态树，服务端很容易初始化状态，易于服务器渲染。state 只能通过 dispatch(action) 来触发更新，更新逻辑由 reducer 来执行。")])]),t._v(" "),a("h3",{attrs:{id:"actions、reducers-和-store"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#actions、reducers-和-store"}},[t._v("#")]),t._v(" Actions、Reducers 和 Store")]),t._v(" "),a("p",[t._v("action 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，比如: "),a("a",{attrs:{href:"https://github.com/acdlite/flux-standard-action/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flux Standard Action"),a("OutboundLink")],1),t._v("。\n为了便于测试和易于扩展，Redux 引入了 Action Creator:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTodo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("text")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ADD_TODO")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    text"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nstore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTodo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("text"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("dispatch(action) 是一个同步的过程：执行 reducer 更新 state -> 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。")])]),t._v(" "),a("p",[t._v("reducer 实际上就是一个函数："),a("code",[t._v("(previousState, action) => newState")]),t._v("。用来执行根据指定 action 来更新 state 的逻辑。通过 combineReducers(reducers) 可以把多个 reducer 合并成一个 root reducer。")]),t._v(" "),a("blockquote",[a("p",[t._v("reducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象（可以考虑使用 "),a("a",{attrs:{href:"http://facebook.github.io/immutable-js/",target:"_blank",rel:"noopener noreferrer"}},[t._v("immutable-js"),a("OutboundLink")],1),t._v("）。")])]),t._v(" "),a("p",[t._v("store 是一个单一对象：")]),t._v(" "),a("ul",[a("li",[t._v("管理应用的 state")]),t._v(" "),a("li",[t._v("通过 "),a("code",[t._v("store.getState()")]),t._v(" 可以获取 state")]),t._v(" "),a("li",[t._v("通过 "),a("font",{attrs:{color:"red",size:"4"}},[a("code",[t._v("store.dispatch(action)")]),t._v(" 来触发 state 更新，也一般是通过action来获取组件的state")])],1),t._v(" "),a("li",[t._v("通过 "),a("code",[t._v("store.subscribe(listener)")]),t._v(" 来注册 state 变化监听器")]),t._v(" "),a("li",[t._v("通过 "),a("code",[t._v("createStore(reducer, [initialState])")]),t._v(" 创建")])]),t._v(" "),a("blockquote",[a("p",[t._v("在 Redux 应用中，只允许有一个 store 对象，可以通过 combineReducers(reducers) 来实现对 state 管理的逻辑划分（多个 reducer）。")])]),t._v(" "),a("h3",{attrs:{id:"middleware"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#middleware"}},[t._v("#")]),t._v(" Middleware")]),t._v(" "),a("p",[t._v("middleware 其实就是高阶函数，作用于 dispatch 返回一个新的 dispatch（附加了该中间件功能）。可以形式化为："),a("code",[t._v("newDispatch = middleware1(middleware2(...(dispatch)...))")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// thunk-middleware")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("thunkMiddleware")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" dispatch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" getState "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("next")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("action")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" action "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'function'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("action")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dispatch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" getState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("action"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("通过 thunk-middleware 我们可以看出中间件的一般形式：中间件函数接受两个参数参数： dispatch 和 getState（也就是说中间件可以获取 state 以及 "),a("code",[t._v("dispatch new action")]),t._v("）。中间件一般返回 "),a("code",[t._v("next(action)")]),t._v("（thunk-middleware 比较特殊，它用于 dispatch 执行异步回调的 action）。store 的创建过程如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" reducer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("combineReducers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reducers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" finalCreateStore "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("applyMiddleware")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("promiseMiddleware"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" warningMiddleware"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    loggerMiddleWare"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("createStore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" store "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("finalCreateStore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reducer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"异步-actions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-actions"}},[t._v("#")]),t._v(" 异步 Actions")]),t._v(" "),a("p",[t._v("单页面应用中充斥着大量的异步请求（ajax）。dispatch(action) 是同步的，如果要处理异步 action，需要使用一些中间件。\n"),a("a",{attrs:{href:"https://github.com/gaearon/redux-thunk/",target:"_blank",rel:"noopener noreferrer"}},[t._v("redux-thunks"),a("OutboundLink")],1),t._v(" 和 "),a("a",{attrs:{href:"https://github.com/aclite/redux-promise/",target:"_blank",rel:"noopener noreferrer"}},[t._v("redux-promise"),a("OutboundLink")],1),t._v(" 分别是使用异步回调和 Promise 来解决异步 action 问题的。")]),t._v(" "),a("h3",{attrs:{id:"redux-和传统-flux-框架的比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-和传统-flux-框架的比较"}},[t._v("#")]),t._v(" Redux 和传统 Flux 框架的比较")]),t._v(" "),a("p",[a("img",{attrs:{src:"ReduxFirst.assets/bVoR1E",alt:"传统 Flux 架构图"}}),t._v(" "),a("img",{attrs:{src:"ReduxFirst.assets/bVoR1G",alt:"Reudx 架构图"}})]),t._v(" "),a("p",[t._v("图来自 "),a("a",{attrs:{href:"http://staltz.com/unidirectional-user-interface-architectures.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("UNIDIRECTIONAL USER INTERFACE ARCHITECTURES"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"redux-和-react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-和-react"}},[t._v("#")]),t._v(" Redux 和 React")]),t._v(" "),a("p",[t._v("Redux 和 React 是没有必然关系的，Redux 用于管理 state，与具体的 View 框架无关。不过，Redux 特别适合那些 "),a("code",[t._v("state => UI")]),t._v(" 的框架（比如：React, Deku）。")]),t._v(" "),a("p",[t._v("可以使用 "),a("a",{attrs:{href:"https://github.com/rackt/react-redux/",target:"_blank",rel:"noopener noreferrer"}},[t._v("react-redux"),a("OutboundLink")],1),t._v(" 来绑定 React，"),a("code",[t._v("react-redux")]),t._v(" 绑定的组件我们一般称之为 "),a("code",[t._v("smart components")]),t._v("，"),a("a",{attrs:{href:"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Smart and Dumb Components"),a("OutboundLink")],1),t._v(" 在 "),a("code",[t._v("react-redux")]),t._v(" 中区分如下：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th",[t._v("Location")]),t._v(" "),a("th",[t._v("Use React-Redux")]),t._v(" "),a("th",[t._v("To read data, they")]),t._v(" "),a("th",[t._v("To change data, they")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("“Smart” Components")]),t._v(" "),a("td",[t._v("Top level, route handlers")]),t._v(" "),a("td",[t._v("Yes")]),t._v(" "),a("td",[t._v("Subscribe to Redux state")]),t._v(" "),a("td",[t._v("Dispatch Redux actions")])]),t._v(" "),a("tr",[a("td",[t._v("“Dumb” Components")]),t._v(" "),a("td",[t._v("Middle and leaf components")]),t._v(" "),a("td",[t._v("No")]),t._v(" "),a("td",[t._v("Read data from props")]),t._v(" "),a("td",[t._v("Invoke callbacks from props")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("简单来看：Smart component` 是连接 Redux 的组件（@connect），一般不可复用。Dumb component 是纯粹的组件，一般可复用。\n两者的共同点是：无状态，或者说状态提取到上层，统一由 redux 的 store 来管理。redux state -> Smart component -> Dumb component -> Dumb component（通过 props 传递）。在实践中，少量 Dumb component 允许自带 UI 状态信息（组件 unmount 后，不需要保留 UI 状态）。\n值得注意的是，Smart component 是应用更新状态的最小单元。实践中，可以将 route handlers 作为 Smart component，一个 Smart component 对应一个 reducer。")]),t._v(" "),a("p",[t._v("更新于 2015-08-28")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000003503338#",target:"_blank",rel:"noopener noreferrer"}},[t._v("分享"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);