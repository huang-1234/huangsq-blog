# 0128 

## 硬链接(hard link)和符号连接(symbolic link)的区别
硬链接(hard link)和符号连接(symbolic link)的区别：

通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小但是事实上却不占任何空间。
符号链接可以理解为类似windows一样的快捷方式。

一、链接文件
链接文件有两种方式，符号链接和硬链接。

1、符号链接文件
符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，也可以链接不同文件系统的文件。甚至可以链接不存在的文件，这就产生一般称为“断裂”的问题（现象），还可以不断的循环链接自己。
用ln -s 命令可以生成一个符号链接，如下所示：
#ln -s source_file  softlink_file
在对符号链接进行读写操作的时候，系统会自动把该操作转换为对源文件的操作。但是删除链接文件时，系统仅仅删除符号链接文件，而不删除源文件本身。

2、硬链接文件
硬链接的命令是：
#ln existfile  newfile
硬链接文件有两个限制
1）、不允许给目录创建硬链接
2）、只允许在同一文件系统中的文件之间才能创建链接

对于硬练级文件进行读写和删除操作的时候，结果和符号链接相同。但是如果我们删除硬链接文件的源文件，硬链接文件仍存在，而且保留了原有的内容。

二、两者之间的区别
硬链接是通过索引节点(inode index)来进行链接的。在linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给他分配一个编号，称为索引节点号（inode index）。

在linux中，多个文件名指向同一索引点是存在的。一般这种链接是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，起到防止“误删”的功能。
因为对应目录的索引节点有一个以上的链接，只删除一个链接并不影响索引节点本身和其他的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，至此文件才被真正删除。

符号链接文件有点类似于windows的快捷方式。他实际上是特殊文件的一种。在符号链接中，文件实际上是一个文本文件，他包含了另一个文件的位置信息。

三、体会
符号链接（symbolic link）在建立的时候建立了一个新的inode，并记录了指向源文件inode的路径。所以symbolic的inode number跟原始档案的inode number是不一样的。这也是为什么symbolic link能够跨越不同文件系统的原因。
符号链接建立了新的inode number，所以它是一个真实的文件并占有一定的磁盘空间。另外对symbolic link的操作除了删除都会直接对源文件进行操作。
硬链接（hard link）并没有新建立inode，而是新建了一个内容以及inode number、hard link文件名和其他相关资讯的一个directory entry，所以hard link的inode number跟源文件的
inode number是一样的。因为一个文件系统有着相同的inode number，所以hard link是不可以跨文件系统创建的。也可以将hard link理解为不是一个文件，把它看成是同一个inode的别名，
建立hard link后他和源文件互为别名，删除其中任何一个，inode都不会释放。只有指向同一inode的文件名都删除后，inode才释放。hard link实际上是不占空间的


## 为什么要用 pnpm 而不是 yarn/npm

### 对依赖包安装的底层实现不同
yarn 和 pnpm 都有 workspace 的功能，然而两者对依赖包安装的底层实现是千差万别的，yarn 的策略是和 npm 类似的，会将公共依赖提升到顶层的 node_modules 目录中，这样按照 node 的模块解析策略略，如果某个依赖在自己的 node_modules 中无法找到，则会逐级向上找，由于 yarn 将公共模块提升了，因此可以在顶层的 node_modules 中找到这个依赖。
看起来好像没什么问题，然而这种策略是有问题的，考虑这样一个场景：
- B 依赖了 A，并将 A 写进了 B 的 package.json 的 dependencies 中
- C 依赖了 A，并将 A 写进了 C 的 package.json 的 dependencies 中
- D 依赖了 A，但没有将将 A 写进 D 的 package.json 的 dependencies 中
根据 yarn 的提升策略，A 会被提升到顶层的 node_modules 中，这时候在本地开发的时候，你基本没可能发现 D 的 package.json 的 dependencies 中少了 A，因为在 D 中依赖 A 的时候，模块解析在自己的 node_modules 中找不到 A 的时候，会逐级向上找，找到了顶层 node_modules，开发时你不会发现依赖缺失的问题。但一旦 D 发布之后，用户安装到本地之后，执行 D 的代码的时候，就会出现依赖 A 找不到的问题，这种问题如果使用 yarn 的话只有发布之后才能发现。
而 pnpm 采用的策略和 yarn 完全不一样，pnpm 会保证每个包的第一级 node_modules 中有且只有这个包的 dependencies 和 devDependencies 中所声明的依赖，不会将公共依赖提升，且 pnpm 会保证每个包下的 node_modules 的目录拓扑结构和 package.json 的完全一致，这可以解决 yarn 提升之后导致的依赖缺失但无法在开发阶段发现的问题。
npm 的 --global-style 可以禁止模块提升行为，但是使用 --global-style 会导致大量的模块重复安装，速度变慢且占用体积变大，而且可能会导致一些问题，比如有副作用的包多次引入会报错（比如 babel-polyfill），同一个模块的内部变量在两个不同目录下导致无法共享（比如 React 有一些内部变量，但是使用 --global-style 的时候，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量）等等。
pnpm 采用了统一的模块存储和硬链接的方法在避免模块提升导致拓扑结构变化的同时保证了不会让同一个版本的包重复安装多次，有关 pnpm 的 node_modules 结构详情可以查看官方的解释文档：https://pnpm.js.org/blog/2020/05/27/flat-node-modules-is-not-the-only-way。

### 可能遇到的问题：
1. pnpm 版本在 package.json 中有要求，文档中的 pnpm 安装语句建议指定版本
2. 执行 npm link 时，提示 `verbose stack Error: Unsupported URL Type "workspace:": workspace:^1.0.3`，经查需要升级 npm 到最新（v7）
3. 继续执行 `eden -v`，执行的文件是 `bin/cli.js` 而不是 `bin/cli-dev.js`，发现是 link 后没有更新 `/usr/local/bin/eden`，即该命令仍然指向 `bin/cli.js`，可能和我安装 node 的方式有关，我是官网下载安装包安装的，此处先删除原先安装的 eden，重新 npm link 即可

